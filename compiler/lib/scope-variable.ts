/// <reference path="../../typings/all.d.ts"/>
"use strict";

import _ = require('lodash');

import ModuleDescriptor = require('./module-descriptor');
import ModuleExportsType = require('./module-exports-type');
import astTypes = require('./ast-types');
import operators = require('./operator-precedence-and-associativity');
import jsGenerator = require('./main');
import variableTypes = require('./variable-types');
import misc = require('./util/misc');

export enum VariableFlags {
    /**
     * This variable is declared in the Angl code with a `var` statement.
     * Only relevant for local variables.
     */
    DECLARED_BY_ANGL                      = 0x00001,
    /**
     * This variable is assigned a value in the Angl code (via an assignment statement: either `var a = 2` or `a = 2`)
     * Only relevant for local variables.
     * TODO remove this?  It's usefulness is eliminated by the presence of DECLARED_AT_ASSIGNMENT
     * and it's tricky to figure out if it was really assigned in Angl or in a generated 'assign' node,
     * since we resolve variables at a late phase of AST transformation.
     */
    ASSIGNED_BY_ANGL                      = 0x00002,
    /**
     * This variable is generated by the compiler (does not come from the original Angl) and a variable declaration
     * will be written by the code generator.  This a declaration does not need to be written at the top of this scope.
     */
    DECLARED_BY_GENERATED_CODE            = 0x00004,
    /**
     * This variable is referenced in the code.  Variables that are not referenced can potentially be removed from the generated code.
     */
    REFERENCED                            = 0x00008,
    /**
     * This variable was generated by the compiler and does not exist in the source Angl code.
     */
    GENERATED                             = 0x00010,

    /*
     * AllocationTypes
     * Enumeration of possible allocationType values.
     * TODO should this be split into allocationType and assignmentType?  Or is that unnecessary complexity/over-engineering?
     * A Variable's AllocationType is how that variable must be declared/allocated in the generated code.
     */

    /**
     * This is a local variable, allocated with a `var` statement.
     */
    LOCAL                                 = 0x00020,
    /**
     * This is a function argument.  It is declared in the function's signature.
     */
    ARGUMENT                              = 0x00040,
    /**
     * This variable is a property of some containing object.
     */
    PROP_ASSIGNMENT                       = 0x00080,
    /**
     * This variable is an imported module.
     * In JS, it's declared and initialized with `var foo = require('./foo');`
     * In TS, it's declared and initialized with `import foo = require('./foo');`
     */
    IMPORT                                = 0x00100,
    /**
     * This variable does not need to be declared or initialized at all.
     */
    NO_ALLOCATION                         = 0x00200,

    ALLOCATION_TYPES = LOCAL | ARGUMENT | PROP_ASSIGNMENT | IMPORT | NO_ALLOCATION,

    /*
     * AccessTypes
     * Enumeration of possible accessType values.
     * A Variable's AccessType is how that variable's value is accessed (setting or getting) in the generated code.
     */

    /**
     * This variable is accessed as a bare identifier in scope.
     * E.g. `foo`
     */
    BARE                                  = 0x00400,
    /**
     * This variable is accessed as a property of some containing object.
     * E.g. `containingObject.foo`
     */
    PROP_ACCESS                           = 0x00800,

    ACCESS_TYPES = BARE | PROP_ACCESS,
    
    USES_THIS_BINDING                     = 0x01000,
    ACCEPTS_OTHER_ARGUMENT                = 0x02000,

    /**
     * This variable is declared by an 'assign' node.
     */
    DECLARED_AT_ASSIGNMENT                = 0x04000,
    
    // Misc other values that should probably be removed
    LOCAL_GENERATED = LOCAL | GENERATED
}

/**
 * Enumeration of possible allocationType values.
 * TODO should this be split into allocationType and assignmentType?  Or is that unnecessary complexity/over-engineering?
 * A Variable's AllocationType is how that variable must be declared/allocated in the generated code.
 */
export enum AllocationType {
    /**
     * This is a local variable, allocated with a `var` statement.
     */
    LOCAL,
    /**
     * This is a local variable, allocated with a `var` statement, that does not exist in the original
     * source code.  It was generated by the angl compiler.
     * These variables don't have a `var` declaration in the original Angl code so we must insert one
     * at the top of the scope.
     */
    LOCAL_GENERATED,
    /**
     * This is a function argument.  It is declared in the function's signature.
     */
    ARGUMENT,
    /**
     * This variable is a property of some containing object.
     */
    PROP_ASSIGNMENT,
    /**
     * This variable is an imported module.
     * In JS, it's declared and initialized with `var foo = require('./foo');`
     * In TS, it's declared and initialized with `import foo = require('./foo');`
     */
    IMPORT,
    /**
     * This variable does not need to be declared or initialized at all.
     */
    NONE
}

/**
 * Enumeration of possible accessType values.
 * A Variable's AccessType is how that variable's value is accessed (setting or getting) in the generated code.
 */
export enum AccessType {
    /**
     * This variable is accessed as a bare identifier in scope.
     * E.g. `foo`
     */
    BARE,
    /**
     * This variable is accessed as a property of some containing object.
     * E.g. `containingObject.foo`
     */
    PROP_ACCESS
}

export interface AbstractVariable {
    awaitingJsIdentifierAssignment():boolean;
    getJsIdentifier():string;
    getIdentifier():string;
    /**
     * @deprecated
     */
    getAllocationType(): VariableFlags;
    /**
     * @deprecated
     */
    getAccessType(): VariableFlags;
    getDataType(): variableTypes.AbstractVariableType;
    canSetDataType(): boolean;
    getFlags(): VariableFlags;
    /**
     * Returns the identifier of the object which this variable is a property of.
     * Some variables are actually properties of another object.
     * E.g. `foo.bar`: this method returns "foo"
     * Otherwise returns null.
     */
    getContainingObjectIdentifier(): string;
    /**
     * Returns the variable representing the object which this variable is a property of.
     * Some variables are actually properties of another object. (e.g. `foo.bar`: `bar`
     * is a property of another variable `foo`)  If that other object (`foo`)
     * is represented by an instance of AbstractVariable, this method returns that AbstractVariable.
     * 
     * If this variable is not a property of another object, or if the containing object is
     * not represented by an instance of AbstractVariable, this method returns null.
     * 
     * See also: getContainingObjectIdentifier
     */
    getContainingObjectVariable(): AbstractVariable;
    /**
     * If this variable is provided by a module, returns the ModuleDescriptor for
     * said module.
     * To be "provided" by the module means that the module must be loaded to use this variable.
     * For example, with node's `fs.readFile`, the `readFile` variable is provided by the `fs` module.
     */
    getProvidedByModule():ModuleDescriptor;
    /**
     * True if this variable, when invoked as a function, will need its `this` value bound to the
     * calling scope's `self` value.
     *   `theVariable.call(this, arg0, arg1, ...)`
     * If false, the `this` value does not need to be set, and the function can be invoked with less overhead.
     *   `theVariable(arg0, arg1, ...)`
     * @deprecated
     */
    getUsesThisBinding():boolean;
    /**
     * True if this variable, when invoked as a function, wants to be passed the value of `other` as its first argument.
     * @deprecated
     */
    getAcceptsOtherArgument(): boolean;
    /**
     * Called by the JS code generator whenever the generated code must invoke this variable as a function.
     * This method can:
     * * return true after generating the function invocation code itself.
     * * return false, in which case default function invocation code will be generated.
     * @param args
     * @param opts
     * @returns {boolean}
     */
    generateInvocation(args: Array<astTypes.ExpressionNode>, codeGenerator: jsGenerator.JsGenerator, parentExpressionType: operators.JavascriptOperatorsEnum, locationInParentExpression: operators.Location, astContext: astTypes.AstNode): boolean;
    /**
     * Called by the JS code generator whenever the generated code must get the value of this variable.
     * This method can:
     * * return true after generating the getter expression.
     * * return false, in which case a default getter expression will be generated.
     * @param opts
     * @returns {boolean}
     */
    generateGetter(codeGenerator: jsGenerator.JsGenerator, parentExpressionType: operators.JavascriptOperatorsEnum, locationInParentExpression: operators.Location, astContext: astTypes.AstNode): boolean;
    /**
     * Called by the JS code generator whenever the generated code must set the value of this variable.
     * This method can:
     * * return true after generating the setting code.
     * * return false, in which case a default setting code will be generated.
     * @param opts
     * @returns {boolean}
     */
    generateSetter(valueToBeSet: astTypes.ExpressionNode, codeGenerator: jsGenerator.JsGenerator, astContext: astTypes.AstNode): boolean;
}

export interface CanSetDataType extends AbstractVariable {
    setDataType(type: variableTypes.AbstractVariableType);
}

/**
 * Not a full implementation of AbstractVariable, but handles some of the gruntwork involved in implementing an
 * AbstractVariable.
 */
export class BaseVariable {
    
    constructor(f: VariableFlags = 0) {
        this._flags = f;
    }
    
    /*protected*/ _flags: VariableFlags;

    // Use a getter and setter, but delegate to simple methods to allow subclasses to override behavior.
    
    get flags(): VariableFlags { return this.getFlags(); }
    getFlags(): VariableFlags {
        return this._flags | this._getComputedFlags();
    }
    
    set flags(f: VariableFlags) { this.setFlags(f); }
    setFlags(f: VariableFlags) {
        this._validateFlags(f);
        this._flags = this._normalizeFlags(f);
    }
    
    /**
     * Throws an error if the given flags are in a state that is not allowed.
     * Used to ensure that this instance's flags are never set to an invalid state.
     */
    /*protected*/ _validateFlags(f: VariableFlags) {
        if((f & this._computedFlagsMask) !== this._getComputedFlags()) throw new Error('cannot set flags into invalid state');
    }

    /**
     * Bitfield of all bits that are computed and thus should not be changed by modifying `flags`
     */
    /*protected*/ _computedFlagsMask: VariableFlags = 0;

    /**
     * Returns a bitfield of the values of all flags that are computed (e.g. hard-coded, delegated to another instance,
     * or derived from some other logic).  These are merged with the `_flags` value to obtain a set of all flags for
     * this instance.
     * @returns {number}
     * @private
     */
    /*protected*/ _getComputedFlags(): number { return 0; }

    /**
     * Normalize flags to a state that can be stored in this._flags
     * The default implementation unsets all computed flags.
     */
    /*protected*/ _normalizeFlags(f: VariableFlags) {
        // set all computed flags to 0
        return f & ~this._computedFlagsMask;
    }
    
    /**
     * @deprecated
     * @returns {VariableFlags}
     */
    getAllocationType(): VariableFlags { return this.flags & VariableFlags.ALLOCATION_TYPES; }

    /**
     * @deprecated
     * @returns {VariableFlags}
     */
    getAccessType(): VariableFlags { return this.flags & VariableFlags.ACCESS_TYPES; }

    /**
     * @deprecated
     * @returns {boolean}
     */
    getUsesThisBinding() { return !!(this.flags & VariableFlags.USES_THIS_BINDING); }

    /**
     * @deprecated
     * @param usesThisBinding
     */
    setUsesThisBinding(usesThisBinding: boolean) {
        this.flags = misc.changeFlags(this.flags, VariableFlags.USES_THIS_BINDING, usesThisBinding);
    }

    /**
     * @deprecated
     * @returns {boolean}
     */
    getAcceptsOtherArgument() { return !!(this.flags & VariableFlags.ACCEPTS_OTHER_ARGUMENT); }

    /**
     * @deprecated
     * @param acceptsOtherArgument
     */
    setAcceptsOtherArgument(acceptsOtherArgument: boolean) {
        this.flags = misc.changeFlags(this.flags, VariableFlags.ACCEPTS_OTHER_ARGUMENT, acceptsOtherArgument);
    }
}

/**
 * Basic implementation of AbstractVariable.
 */
export class Variable extends BaseVariable implements AbstractVariable, CanSetDataType {

    private _identifier:string;
    //private _allocationType: VariableFlags;
    //private _accessType: VariableFlags;
    private _desiredJsIdentifier:string;
    private _jsIdentifier:string;
    private _containingObjectIdentifier:string;
    private _providedByModule: ModuleDescriptor;
    //private _usesThisBinding: boolean;
    //private _acceptsOtherArgument: boolean;
    private _dataType: variableTypes.AbstractVariableType;

    constructor(identifier: string = null, allocationType: VariableFlags = VariableFlags.LOCAL | VariableFlags.GENERATED, accessType: VariableFlags = VariableFlags.BARE) {
        super(allocationType | accessType);
        this._identifier = identifier;
        this._jsIdentifier = identifier;
        this._desiredJsIdentifier = null;
        //this._allocationType = allocationType;
        //this._accessType = accessType;
        this._containingObjectIdentifier = null;
        this._providedByModule = null;
        //this._usesThisBinding = false;
        //this._acceptsOtherArgument = false;
        this._dataType = null;
    }

    awaitingJsIdentifierAssignment() { return !this._jsIdentifier; }

    /**
     * Sets the identifier that this variable would like to have in the generated JavaScript.
     * It may or may not get this identifier, depending on if their are identifier collisions.
     * @param desiredIdentifier
     */
    setDesiredJsIdentifier(desiredIdentifier:string) { this._desiredJsIdentifier = desiredIdentifier; }

    getDesiredJsIdentifier():string { return this._desiredJsIdentifier; }

    /**
     * Sets the identifier that this variable will have in the generated JavaScript.
     * @param jsIdentifier
     */
    setJsIdentifier(jsIdentifier:string) { this._jsIdentifier = jsIdentifier; }

    getJsIdentifier():string { return this._jsIdentifier; }

    /**
     * Sets the identifier that this variable has in Angl.
     * @param identifier
     */
    setIdentifier(identifier:string) { this._identifier = identifier; }

    getIdentifier():string { return this._identifier; }
    
    getDataType() {
        return this._dataType;
    }
    
    canSetDataType() {
        return true;
    }
    
    setDataType(dataType: variableTypes.AbstractVariableType) {
        this._dataType = dataType;
    }

    /**
     * Sets the identifier of the containing object (the object that contains this variable).
     * For a PROP-ACCESS variable, the variable is actually a property of another object.
     * It is accessed in JavaScript using "containingObject.variableIdentifier"
     * @param identifier
     */
    setContainingObjectIdentifier(identifier:string) { this._containingObjectIdentifier = identifier; }

    getContainingObjectIdentifier():string { return this._containingObjectIdentifier; }
    
    getContainingObjectVariable() { return null; }
    
    setProvidedByModule(moduleDescriptor: ModuleDescriptor) { this._providedByModule = moduleDescriptor; }

    getProvidedByModule() { return this._providedByModule; }
    
    generateInvocation(args: Array<astTypes.ExpressionNode>, codeGenerator: jsGenerator.JsGenerator, parentExpressionType: operators.JavascriptOperatorsEnum, locationInParentExpression: operators.Location, astContext: astTypes.AstNode): boolean {
        return false;
    }
    
    generateGetter(codeGenerator: jsGenerator.JsGenerator, parentExpressionType: operators.JavascriptOperatorsEnum, locationInParentExpression: operators.Location, astContext: astTypes.AstNode): boolean {
        return false;
    }

    generateSetter(valueToBeSet: astTypes.ExpressionNode, codeGenerator: jsGenerator.JsGenerator, astContext: astTypes.AstNode): boolean {
        return false;
    }

}

/**
 * A variable created in a File scope that proxies to the corresponding variable in a module.
 * For example, if module "foo-module" exposes a property "bar" (for our purposes, module properties
 * == module variables) and is loaded as follows:
 *     `var foo = require('foo');`
 * the ProxyToModuleVariable for bar would generate code that looks like:
 *     `foo.bar`
 * It knows the local variable for that module (foo) so it can generate the correct code.  This local
 * variable (foo) can potentially be different in different files, which is why ProxyToModuleVariable
 * instances are created.
 */
export class ProxyToModuleProvidedVariable extends BaseVariable implements AbstractVariable {
    private _moduleVariable: AbstractVariable;
    private _moduleProvidedVariable: AbstractVariable;
    
    constructor(moduleProvidedVariable: AbstractVariable, moduleVariable: AbstractVariable) {
        super();
        this._moduleVariable = moduleVariable;
        this._moduleProvidedVariable = moduleProvidedVariable;
        // Sanity-check that we know the export type of the module providing this variable (SINGLE or MULTI).
        // UNKNOWN is not allowed.
        if(this._moduleProvidedVariable.getProvidedByModule().exportsType === ModuleExportsType.UNKNOWN)
            throw new Error('Cannot create proxyToModuleProvidedVariable for a module with exportsType UNKNOWN.');
        this._flags = this._getComputedFlags();
    }
    
    getModuleProvidedVariable(): AbstractVariable { return this._moduleProvidedVariable; }
    
    awaitingJsIdentifierAssignment() { return false; }
    
    getJsIdentifier() {
        if(this._moduleProvidedVariable.getProvidedByModule().exportsType === ModuleExportsType.MULTI) {
            return this._moduleProvidedVariable.getJsIdentifier();
        } else {
            return this._moduleVariable.getJsIdentifier();
        }
    }
    
    getIdentifier() {
        if(this._moduleProvidedVariable.getProvidedByModule().exportsType === ModuleExportsType.MULTI) {
            return this._moduleProvidedVariable.getIdentifier();
        } else {
            return this._moduleVariable.getIdentifier();
        }
    }
    
    /*protected*/ _computedFlagsMask: VariableFlags = VariableFlags.USES_THIS_BINDING
                                                    | VariableFlags.ACCEPTS_OTHER_ARGUMENT
                                                    | VariableFlags.ALLOCATION_TYPES
                                                    | VariableFlags.ACCESS_TYPES;
    
    /*protected*/ _getComputedFlags() {
        var ret = (this._moduleProvidedVariable.getFlags() & (VariableFlags.USES_THIS_BINDING | VariableFlags.ACCEPTS_OTHER_ARGUMENT))
                | this.getAccessType()
                | VariableFlags.NO_ALLOCATION;
        return ret;
    }
    
    getAccessType() {
        if(this._moduleProvidedVariable.getProvidedByModule().exportsType === ModuleExportsType.MULTI) {
            return VariableFlags.PROP_ACCESS;
        } else {
            return VariableFlags.BARE;
        }
    }
    
    getDataType() {
        return this._moduleProvidedVariable.getDataType();
    }
    
    canSetDataType() {
        return false;
    }
    
    private _isPropertyOfModuleVariable(): boolean {
        return this._moduleProvidedVariable.getProvidedByModule().exportsType === ModuleExportsType.MULTI;
    }
    
    getContainingObjectIdentifier() {
        if(this._isPropertyOfModuleVariable()) {
            return this._moduleVariable.getJsIdentifier();
        } else {
            return null;
        }
    }
    
    getContainingObjectVariable() {
        if(this._isPropertyOfModuleVariable()) {
            return this._moduleVariable;
        } else {
            return null;
        }
    }
    
    getProvidedByModule() { return null; }
    
    generateGetter(codeGenerator, parentExpressionType, locationInParentExpression, astContext) {
        return this._moduleProvidedVariable.generateGetter(codeGenerator, parentExpressionType, locationInParentExpression, astContext);
    }
    
    generateSetter(valueToSet, codeGenerator, astContext) {
        return this._moduleProvidedVariable.generateSetter(valueToSet, codeGenerator, astContext);
    }
    
    generateInvocation(args, codeGenerator, parentExpressionType, locationInParentExpression, astContext) {
        return this._moduleProvidedVariable.generateInvocation(args, codeGenerator, parentExpressionType, locationInParentExpression, astContext);
    }
   
}

/**
 * This variable is placed in global scope and proxies to the local version of an exported variable in a module.
 */
export class GlobalVersionOfExportedVariable extends Variable {
    private _var: Variable;
    constructor(exportedVariable: Variable, fileModule: ModuleDescriptor, identifier: string, allocationType?: VariableFlags, accessType?: VariableFlags) {
        super(identifier, allocationType, accessType);
        this._var = exportedVariable;
        this.setProvidedByModule(fileModule);
        this._computedFlagsMask = VariableFlags.USES_THIS_BINDING | VariableFlags.ACCEPTS_OTHER_ARGUMENT;
    }
    
    getLocalVariable(): Variable { return this._var; }
    
    _getComputedFlags() {
        return this._var.flags & (VariableFlags.USES_THIS_BINDING | VariableFlags.ACCEPTS_OTHER_ARGUMENT);
    }
    
    setFlags(f) {
        // Setting certain flags delegates to `this._var`
        this._var.flags = misc.copyFlags(this._var.flags, VariableFlags.USES_THIS_BINDING | VariableFlags.ACCEPTS_OTHER_ARGUMENT, f);
        super.setFlags(f);
    }
    
    getDataType() { return this._var.getDataType(); }
    setDataType(dataType) {return this._var.setDataType(dataType); }
    canSetDataType() { return this._var.canSetDataType(); }
    
    getIdentifier() { return this._var.getIdentifier(); }
    getJsIdentifier() { return this._var.getJsIdentifier(); }
    
}
